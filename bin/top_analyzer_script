#!/usr/bin/env ruby

require 'lib/top_analyzer'
require 'lib/top_process'
require 'lib/top_matcher'
require 'date'
require 'optparse'

options = {}

opts = OptionParser.new do |opts|
  opts.banner = <<-DESC
  
  Top Analyzer
  =================================
  
  Prints to stdout a csv file containing information extracted from a batch top output
  Developed against top: procps version 3.2.7
  
  The input file can be obtained via a top command, as in this example:
    # Top
    # -b -> batch mode
    # -n -> number of samples
    # -d -> delay between samples
    top -b -n 360 -d 10
  
  Usage: ruby top_analyzer FILE [OPTIONS]

  DESC

  options[:target] = :memory_percentage
  opts.on( '-t', '--target=TARGET', <<-DESC ) do |target|
    monitoring target
      Defines which variable from the top command will be analyzed
      Current TARGET options are:
      m - memory percentage      
    DESC
    
    case target
    when "m"
      options[:target] = :memory_percentage
    else
      options[:target] = :memory_percentage
    end
  end

  options[:limit] = 0
  opts.on( '-l', '--limit=LIMIT', <<-DESC ) do |limit|
    monitoring lower limit
      If this variable is set processes that have all samples lower 
      than LIMIT won't be returned in the output.
    DESC
    options[:limit] = limit.to_f
  end
  
  options[:start_time] = nil
  opts.on( '-st', '--starttime=TIME', <<-DESC ) do |start_time|
    monitoring start time
      If this variable is set only samples obtained after TIME
      will be considered. TIME must be provided in the HH:MM:SS 
      format
    DESC
    options[:start_time] = DateTime.strptime(start_time, "%H:%M:%S")
  end
  
  options[:end_time] = nil
  opts.on( '-et', '--endtime=TIME', <<-DESC ) do |end_time|
    monitoring start time
      If this variable is set only samples obtained before TIME
      will be considered. TIME must be provided in the HH:MM:SS 
      format
    DESC
    options[:end_time] = DateTime.strptime(end_time, "%H:%M:%S")
  end
  

  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end

if (ARGV.empty?) 
  puts opts.help
else  
  opts.parse!(ARGV)
  top_file = File.new(ARGV[0])
  
  analyzer = TopAnalyzer.new(top_file,options)
  $stdout.print analyzer.analyze
end